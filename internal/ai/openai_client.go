package ai

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"regexp"
	"strings"
	"time"

	clickhouseparser "github.com/AfterShip/clickhouse-sql-parser/parser"
	"github.com/sashabaranov/go-openai"
)

// ErrInvalidSQLGeneratedByAI is returned when the SQL generated by AI is not parsable.
var ErrInvalidSQLGeneratedByAI = errors.New("AI generated invalid SQL syntax")

// Regular expressions to match markdown code blocks
var codeBlockRegex = regexp.MustCompile("(?s)```(?:sql)?\\s*(.*?)```")

const (
	DefaultOpenAIModel             = openai.GPT4o
	DefaultMaxTokens               = 1024
	DefaultTemperature             = float32(0.1)
	DefaultTimeout                 = 15 * time.Second // Used for both HTTP client and individual call fallback
	DefaultSystemPromptTableFormat = `You are an expert ClickHouse SQL query assistant for log analytics. Given a table schema and a natural language query, generate an optimized and correct ClickHouse SQL query. Important guidelines:

1. Only use columns present in the provided schema.
2. The table name to query is: %s
3. Always include the table name in the FROM clause.
4. Include proper time range filters if the user is asking about specific time periods.
5. When aggregating data, use ClickHouse-specific functions.
6. ALWAYS include a LIMIT clause with a reasonable limit (use LIMIT 100 by default if not specified).
7. For timestamp fields, use toDateTime functions with timezone support like: toDateTime('2025-05-14 15:00:10', 'Asia/Kolkata')
8. For pattern matching:
   - Use positionCaseInsensitive(column, 'pattern') > 0 when the user wants to find content containing a substring (e.g., "contains", "includes", "has")
   - Use = or equals for exact matches (e.g., "equals", "is", "matches exactly")
   - Use LIKE for simple wildcard patterns, but prefer positionCaseInsensitive for most substring searches
9. Order results by timestamp DESC for log analytics queries unless specified otherwise
10. Output ONLY the executable SQL query - NO code fences, NO markdown formatting, NO explanation.
11. Provide ONLY the raw SQL query itself with no additional formatting or markup.

Example query patterns:
SELECT *
FROM default.logs
WHERE timestamp BETWEEN toDateTime('2025-05-14 15:00:10', 'Asia/Kolkata') AND toDateTime('2025-05-14 15:30:10', 'Asia/Kolkata') AND (positionCaseInsensitive(namespace, 'helo') > 0)
ORDER BY timestamp DESC
LIMIT 100

Provided schema:
%s`
)

// OpenAIClient represents a client for interacting with OpenAI's API
type OpenAIClient struct {
	client      *openai.Client
	logger      *slog.Logger
	model       string
	maxTokens   int
	temperature float32
	callTimeout time.Duration // Timeout for individual GenerateSQL calls
}

// ClientOptions contains settings for creating an OpenAI client
type ClientOptions struct {
	APIKey      string
	Model       string
	MaxTokens   int
	Temperature float32
	Timeout     time.Duration // This timeout is used for HTTP client and as default for callTimeout
	BaseURL     string
}

// NewClient creates a new OpenAI client with the given options
func NewClient(opts ClientOptions, logger *slog.Logger) (*OpenAIClient, error) {
	if opts.APIKey == "" {
		return nil, fmt.Errorf("OpenAI API key not provided")
	}

	clientModel := opts.Model
	if clientModel == "" {
		clientModel = DefaultOpenAIModel
	}
	clientMaxTokens := opts.MaxTokens
	if clientMaxTokens == 0 {
		clientMaxTokens = DefaultMaxTokens
	}
	clientTemperature := opts.Temperature
	if clientTemperature == 0 {
		clientTemperature = DefaultTemperature
	}
	clientCallTimeout := opts.Timeout // Default call timeout to the general timeout
	if clientCallTimeout == 0 {
		clientCallTimeout = DefaultTimeout
	}
	httpClientTimeout := opts.Timeout // Timeout for the underlying HTTP client
	if httpClientTimeout == 0 {
		httpClientTimeout = DefaultTimeout
	}

	config := openai.DefaultConfig(opts.APIKey)
	// Configure a custom HTTP client with the specified timeout
	httpClient := &http.Client{
		Timeout: httpClientTimeout,
	}
	config.HTTPClient = httpClient // Assign the custom client

	if opts.BaseURL != "" {
		config.BaseURL = opts.BaseURL
		logger.Debug("using custom OpenAI base URL", "base_url", opts.BaseURL)
	}

	client := openai.NewClientWithConfig(config)
	return &OpenAIClient{
		client:      client,
		logger:      logger.With("component", "openai_client"),
		model:       clientModel,
		maxTokens:   clientMaxTokens,
		temperature: clientTemperature,
		callTimeout: clientCallTimeout,
	}, nil
}

// GenerateSQL generates a SQL query from a natural language query and schema.
// It uses the model, maxTokens, and temperature configured during client initialization.
// The provided context should handle overall timeout; this method applies an additional
// internal timeout (c.callTimeout) for the specific API call.
func (c *OpenAIClient) GenerateSQL(
	ctx context.Context,
	naturalLanguageQuery string,
	schema string,
	tableName string,
	currentQuery string, // Optional current query for context
) (string, error) {
	c.logger.Debug("generating SQL from natural language query",
		"query_length", len(naturalLanguageQuery),
		"schema_length", len(schema),
		"table", tableName,
		"current_query_length", len(currentQuery),
		"client_model", c.model,
		"client_max_tokens", c.maxTokens,
		"client_temperature", c.temperature,
		"client_call_timeout", c.callTimeout,
	)

	callCtx, cancel := context.WithTimeout(ctx, c.callTimeout)
	defer cancel()

	now := time.Now()
	systemPrompt := fmt.Sprintf(DefaultSystemPromptTableFormat, tableName, schema)

	// Build user prompt with optional current query context
	var userPrompt string
	if currentQuery != "" && strings.TrimSpace(currentQuery) != "" {
		userPrompt = fmt.Sprintf("Generate a ClickHouse SQL query to answer this question: %s. The current time is %s.\n\nFor context, here is the user's current query:\n%s\n\nPlease use this current query as a reference and modify it as needed to answer the user's question.",
			naturalLanguageQuery, now.Format(time.RFC3339), currentQuery)
	} else {
		userPrompt = fmt.Sprintf("Generate a ClickHouse SQL query to answer this question: %s. The current time is %s.",
			naturalLanguageQuery, now.Format(time.RFC3339))
	}

	c.logger.Debug("using model configuration for GenerateSQL call",
		"model", c.model,
		"max_tokens", c.maxTokens,
		"temperature", c.temperature,
	)

	resp, err := c.client.CreateChatCompletion(
		callCtx,
		openai.ChatCompletionRequest{
			Model: c.model,
			Messages: []openai.ChatCompletionMessage{
				{
					Role:    openai.ChatMessageRoleSystem,
					Content: systemPrompt,
				},
				{
					Role:    openai.ChatMessageRoleUser,
					Content: userPrompt,
				},
			},
			MaxTokens:   c.maxTokens,
			Temperature: c.temperature,
		},
	)

	if err != nil {
		c.logger.Error("error calling OpenAI API", "error", err)
		return "", fmt.Errorf("OpenAI API error: %w", err)
	}

	if len(resp.Choices) == 0 {
		return "", fmt.Errorf("no response received from OpenAI API")
	}

	rawGeneratedSQL := resp.Choices[0].Message.Content
	cleanedSQL := removeMarkdownSQL(rawGeneratedSQL)

	if cleanedSQL == "" {
		// This case might indicate the AI returned an empty response after stripping markdown
		c.logger.Warn("AI returned an empty response after markdown removal")
		return "", ErrInvalidSQLGeneratedByAI // Treat empty as invalid
	}

	validatedSQL, err := validateAndFormatSQL(cleanedSQL)
	if err != nil {
		c.logger.Error("AI generated SQL failed validation", "raw_sql", cleanedSQL, "error", err)
		// err from validateAndFormatSQL is already ErrInvalidSQLGeneratedByAI if parsing failed
		return "", err
	}

	c.logger.Debug("successfully generated and validated SQL",
		"validated_sql_length", len(validatedSQL),
		"input_tokens", resp.Usage.PromptTokens,
		"output_tokens", resp.Usage.CompletionTokens,
		"total_tokens", resp.Usage.TotalTokens,
	)

	return validatedSQL, nil
}

// removeMarkdownSQL strips markdown code fences (```sql ... ``` or ``` ... ```)
// and any surrounding whitespace from the AI's raw output.
func removeMarkdownSQL(rawResponse string) string {
	matches := codeBlockRegex.FindStringSubmatch(rawResponse)
	var sql string
	if len(matches) > 1 {
		// Extract the content from within the code block
		sql = matches[1]
	} else {
		// No code blocks found, so just remove any backtick markers if present
		sql = strings.ReplaceAll(rawResponse, "```sql", "") // Order matters: ```sql before ```
		sql = strings.ReplaceAll(sql, "```", "")
	}
	return strings.TrimSpace(sql)
}

// validateAndFormatSQL tries to parse the given SQL string using a ClickHouse parser.
// If parsing is successful, it returns the formatted SQL.
// If parsing fails, or the resulting SQL is empty, it returns ErrInvalidSQLGeneratedByAI.
func validateAndFormatSQL(sqlInput string) (string, error) {
	if strings.TrimSpace(sqlInput) == "" {
		return "", ErrInvalidSQLGeneratedByAI // Empty input is invalid
	}

	// Handle escaped single quotes ('') which the parser might misinterpret
	const placeholder = "___ESCAPED_QUOTE___"
	processedSQL := strings.ReplaceAll(sqlInput, "''", placeholder)

	parser := clickhouseparser.NewParser(processedSQL)
	stmts, err := parser.ParseStmts()

	if err != nil {
		// Parsing failed
		return "", fmt.Errorf("%w: %v", ErrInvalidSQLGeneratedByAI, err)
	}

	if len(stmts) == 0 {
		// Parsing succeeded but no statements were found
		return "", ErrInvalidSQLGeneratedByAI
	}

	// The String() method of the parser provides properly formatted SQL
	formattedSQL := stmts[0].String()
	// Restore escaped quotes
	formattedSQL = strings.ReplaceAll(formattedSQL, placeholder, "''")
	formattedSQL = strings.TrimSpace(formattedSQL) // Ensure formatted SQL isn't just whitespace

	// Validate that we have a non-empty SQL query after formatting
	if formattedSQL == "" {
		return "", ErrInvalidSQLGeneratedByAI
	}

	return formattedSQL, nil
}
